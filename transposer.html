<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Algebra Touch: Education Edition</title>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <style>
    :root { --bg: #0f172a; --surface: #1e293b; --accent: #6366f1; --err: #ef4444; --text: #f8fafc; --locked: #64748b; }
    body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', system-ui, sans-serif; margin: 0; min-height: 100vh; display: flex; flex-direction: column; overflow-x: hidden; user-select: none; }

    /* --- WELCOME SECTION --- */
    .welcome-section {
        background: linear-gradient(to bottom, #1e293b, #0f172a);
        padding: 3rem 2rem;
        border-bottom: 1px solid #334155;
        text-align: center;
    }
    .welcome-container { max-width: 800px; margin: 0 auto; text-align: left; }
    h1 { color: #a5b4fc; margin: 0 0 1rem 0; font-size: 2.5rem; letter-spacing: -1px; text-align: center; }
    p.subtitle { color: #94a3b8; font-size: 1.1rem; text-align: center; margin-bottom: 2rem; }
    
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 2rem; }
    .card { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); padding: 1.5rem; border-radius: 12px; }
    .card h3 { color: #e2e8f0; margin-top: 0; font-size: 1.1rem; border-bottom: 2px solid var(--accent); display: inline-block; padding-bottom: 5px; margin-bottom: 10px; }
    .card ul { padding-left: 20px; color: #cbd5e1; line-height: 1.6; margin: 0; }
    .card li { margin-bottom: 8px; }
    
    code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; font-family: monospace; color: #bef264; font-size: 0.9em; }

    /* --- APP INTERFACE --- */
    .app-container { flex: 1; display: flex; flex-direction: column; height: 80vh; border-top: 1px solid var(--accent); position: relative; }
    
    .ui { padding: 1rem 2rem; background: #0f172a; display: flex; gap: 10px; border-bottom: 1px solid #334155; z-index: 10; justify-content: center; }
    .input-group { display: flex; max-width: 800px; width: 100%; gap: 10px; }
    input { flex: 1; background: #1e293b; border: 1px solid #334155; color: #f8fafc; padding: 12px; border-radius: 8px; font-family: monospace; font-size: 1.2rem; outline: none; transition: 0.2s; }
    input:focus { border-color: var(--accent); background: #252f45; }
    button { background: var(--accent); color: white; border: none; padding: 0 24px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: 0.2s; white-space: nowrap; }
    button:hover { filter: brightness(1.1); transform: translateY(-1px); }
    button.secondary { background: #475569; }

    .arena { flex: 1; display: flex; justify-content: center; align-items: center; font-size: 3.5rem; position: relative; background: #020617; }
    .side { display: flex; align-items: center; justify-content: center; min-width: 120px; min-height: 100px; padding: 40px; border-radius: 20px; transition: 0.3s; border: 2px solid transparent; }
    .side.drag-target { background: rgba(99, 102, 241, 0.1); border-color: var(--accent); box-shadow: 0 0 40px rgba(99, 102, 241, 0.1); }

    /* --- NODES & LOGIC --- */
    .node { display: inline-flex; align-items: center; transition: 0.2s; position: relative; margin: 0 1px; }
    .draggable { cursor: grab; border-radius: 6px; transition: 0.2s; }
    .draggable:hover { background: rgba(99, 102, 241, 0.25); box-shadow: 0 0 0 1px var(--accent); z-index: 10; transform: scale(1.02); }
    .locked { cursor: not-allowed; opacity: 0.7; filter: grayscale(1); }
    .locked:hover { background: rgba(239, 68, 68, 0.15); box-shadow: 0 0 0 1px var(--err); }
    
    .fraction { display: inline-flex; flex-direction: column; align-items: center; vertical-align: middle; margin: 0 6px; }
    .frac-line { width: 100%; height: 2px; background: currentColor; margin: 4px 0; border-radius: 2px; }
    
    .superscript { font-size: 0.75em; vertical-align: super; margin-left: 2px; display: inline-flex; align-items: center; }
    .fraction-exp { font-size: 0.6em; vertical-align: super; margin-left: 2px; transform: translateY(-0.5em); display: inline-flex; }

    /* SVG Root */
    .root-wrapper { display: inline-flex; align-items: stretch; position: relative; margin-right: 2px; }
    .root-symbol { width: 20px; position: relative; cursor: grab; z-index: 5; margin-right: -2px; }
    .root-svg { position: absolute; right: 0; bottom: 0; width: 100%; height: 100%; overflow: visible; }
    .root-content { border-top: 2px solid currentColor; padding-top: 2px; padding-left: 2px; display: inline-flex; align-items: center; margin-top: 8px; }

    /* Special Elements */
    .paren { font-weight: 300; opacity: 0.6; transform: scaleY(1.1); display: inline-block; margin: 0 2px; }
    .op { margin: 0 12px; color: #94a3b8; font-size: 0.8em; font-weight: 300; }
    .equals { margin: 0 60px; cursor: pointer; transition: 0.3s; color: #94a3b8; }
    .equals:hover { color: var(--accent); transform: scale(1.2); }
    
    /* Draggable Minus */
    .negative-sign { font-weight: bold; margin-right: 2px; cursor: grab; color: inherit; padding: 0 4px; transition: 0.2s; border-radius: 4px; }
    .negative-sign.draggable:hover { background: rgba(99, 102, 241, 0.25); color: #a5b4fc; box-shadow: 0 0 0 1px var(--accent); }

    #toast { position: fixed; bottom: 40px; left: 50%; transform: translate(-50%, 20px); background: var(--err); color: white; padding: 12px 24px; border-radius: 50px; opacity: 0; transition: 0.3s; pointer-events: none; font-weight: 600; z-index: 1000; box-shadow: 0 10px 20px rgba(0,0,0,0.3); }
    #toast.show { opacity: 1; transform: translate(-50%, 0); }
    .ghost { position: fixed; pointer-events: none; z-index: 9999; background: #1e293b; padding: 10px 20px; border-radius: 8px; border: 2px solid var(--accent); font-size: 2.5rem; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
  </style>
</head>
<body>

<section class="welcome-section">
  <div class="welcome-container">
    <h1>Algebra Touch</h1>
    <p class="subtitle">A dynamic tool to visualize and solve equations through gesture.</p>
    
    <div class="grid">
      <div class="card">
        <h3>How to Type</h3>
        <ul>
          <li><strong>Powers:</strong> Type <code>x^2</code></li>
          <li><strong>Roots:</strong> Type <code>sqrt(x)</code> or <code>x^(1/2)</code></li>
          <li><strong>Fractions:</strong> Type <code>(x+1)/2</code></li>
          <li><strong>Multiplication:</strong> <code>2x</code> or <code>2*x</code></li>
        </ul>
      </div>
      
      <div class="card">
        <h3>How to Solve</h3>
        <ul>
          <li><strong>Drag Terms:</strong> Move numbers across the <code>=</code> sign to apply the inverse.</li>
          <li><strong>Peel the Onion:</strong> Move outermost terms first (e.g., remove the constant before the coefficient).</li>
          <li><strong>Square Roots:</strong> Click the <code>√</code> tick to square the other side.</li>
        </ul>
      </div>

      <div class="card">
        <h3>Pro Tips</h3>
        <ul>
          <li><strong>Negatives:</strong> You can drag the <code>-</code> sign from a variable (e.g., <code>-x</code>) to divide by -1.</li>
          <li><strong>Fractions:</strong> You can drag the denominator (e.g., the 2 in <code>1/2</code>) to multiply.</li>
          <li><strong>Auto-Flip:</strong> If you isolate <code>5 = x</code>, it will auto-flip to <code>x = 5</code>.</li>
        </ul>
      </div>
    </div>
  </div>
</section>

<div class="app-container">
  <div class="ui">
    <div class="input-group">
      <input id="eqInput" value="-x = 5">
      <button onclick="engine.load()">Load Equation</button>
      <button class="secondary" onclick="engine.undo()">Undo</button>
    </div>
  </div>

  <div class="arena">
    <div id="LHS" class="side"></div>
    <div class="equals" onclick="engine.flip()">=</div>
    <div id="RHS" class="side"></div>
  </div>
</div>

<div id="toast">Error</div>

<script>
// --- CLASSES ---
class Node { constructor(type) { this.type = type; this.id = Math.random().toString(36).substr(2, 9); } }
class Atom extends Node { constructor(val) { super('atom'); this.val = val; } }
class OpNode extends Node { constructor(type, children) { super(type); this.children = children; } }
class DivNode extends Node { constructor(num, den) { super('div'); this.num = num; this.den = den; } }
class PowerNode extends Node { constructor(base, exp) { super('pow'); this.base = base; this.exp = exp; } }

// --- ENGINE ---
class AlgebraEngine {
  constructor() {
    this.state = { lhs: null, rhs: null };
    this.history = [];
  }

  load() {
    const rawInput = document.getElementById('eqInput').value;
    const procInput = rawInput.replace(/sqrt\(([^)]+)\)/g, '($1)^(1/2)'); // Pre-process Sqrt
    
    const [l, r] = procInput.split('=');
    this.state.lhs = this.parseExpression(l);
    this.state.rhs = this.parseExpression(r);
    this.history = [];
    this.simplifyStep();
    this.save();
    this.render();
    
    // Auto scroll to arena on load
    document.querySelector('.app-container').scrollIntoView({ behavior: 'smooth' });
  }

  restore(node) {
    if (!node) return null;
    let newNode;
    if (node.type === 'atom') newNode = new Atom(node.val);
    else if (node.type === 'add' || node.type === 'mult') newNode = new OpNode(node.type, node.children.map(c => this.restore(c)));
    else if (node.type === 'div') newNode = new DivNode(this.restore(node.num), this.restore(node.den));
    else if (node.type === 'pow') newNode = new PowerNode(this.restore(node.base), this.restore(node.exp));
    if(newNode) newNode.id = node.id;
    return newNode;
  }

  undo() {
    if (this.history.length > 1) {
        this.history.pop();
        const rawState = JSON.parse(this.history[this.history.length - 1]);
        this.state.lhs = this.restore(rawState.lhs);
        this.state.rhs = this.restore(rawState.rhs);
        this.render();
    }
  }

  // --- PARSING ---
  parseExpression(str) {
    if (!str) return new Atom('0');
    let tokens = this.tokenize(str);
    return this.parseAdd(tokens);
  }
  tokenize(str) {
    str = str.replace(/\s+/g, '');
    const regex = /([+\-*/^()])|([a-zA-Z](?:_[a-zA-Z0-9]+)?)|([0-9]+\.?[0-9]*)/g;
    const tokens = [];
    let match;
    while ((match = regex.exec(str)) !== null) if (match[0]) tokens.push(match[0]);
    return tokens;
  }
  parseAdd(tokens) {
    let left = this.parseMult(tokens);
    while (tokens.length > 0 && (tokens[0] === '+' || tokens[0] === '-')) {
      const op = tokens.shift();
      const right = this.parseMult(tokens);
      if (op === '-') {
        const neg = new OpNode('mult', [new Atom('-1'), right]);
        if (left.type === 'add') left.children.push(neg);
        else left = new OpNode('add', [left, neg]);
      } else {
        if (left.type === 'add') left.children.push(right);
        else left = new OpNode('add', [left, right]);
      }
    }
    return left;
  }
  parseMult(tokens) {
    let left = this.parsePower(tokens);
    while (tokens.length > 0) {
      const t = tokens[0];
      if (t === '*' || t === '/') {
        const op = tokens.shift();
        const right = this.parsePower(tokens);
        if (op === '/') left = new DivNode(left, right);
        else {
          if (left.type === 'mult') left.children.push(right);
          else left = new OpNode('mult', [left, right]);
        }
      } else if (t !== '+' && t !== '-' && t !== ')') {
        const right = this.parsePower(tokens);
        if (left.type === 'mult') left.children.push(right);
        else left = new OpNode('mult', [left, right]);
      } else break;
    }
    return left;
  }
  parsePower(tokens) {
    let left = this.parseAtom(tokens);
    if (tokens.length > 0 && tokens[0] === '^') {
      tokens.shift();
      const right = this.parseAtom(tokens);
      left = new PowerNode(left, right);
    }
    return left;
  }
  parseAtom(tokens) {
    const t = tokens.shift();
    if (t === '(') {
      const node = this.parseAdd(tokens);
      tokens.shift();
      return node;
    }
    return new Atom(t);
  }

  // --- LOGIC GATES ---
  getMovableNode(path, sideRoot) {
    for (let i = path.length - 1; i >= 0; i--) {
        const node = path[i];
        if (this.checkMove(node, path.slice(0, i+1), sideRoot)) return node;
    }
    return null;
  }

  checkMove(node, path, sideRoot) {
    if (node === sideRoot) return true;
    const parent = path.length > 1 ? path[path.length - 2] : null;
    if (!parent) return false;

    if (sideRoot.type === 'add') return parent === sideRoot;
    if (sideRoot.type === 'mult') {
        if (parent === sideRoot) return true;
        const grandparent = path.length > 2 ? path[path.length - 3] : null;
        if (parent.type === 'div' && node === parent.den && grandparent === sideRoot) return true;
        return false;
    }
    if (sideRoot.type === 'div') return node === sideRoot.den;
    if (sideRoot.type === 'pow') {
        if (node === sideRoot.exp) return true;
        const grandparent = path.length > 2 ? path[path.length - 3] : null;
        if (parent.type === 'div' && node === parent.den && grandparent === sideRoot && parent === sideRoot.exp) return true;
        return false;
    }
    return false;
  }

  move(node, targetSideName) {
    this.save();
    const sourceSideName = targetSideName === 'LHS' ? 'rhs' : 'lhs';
    const targetSideKey = targetSideName === 'LHS' ? 'lhs' : 'rhs';
    const root = this.state[sourceSideName];
    
    const path = this.findPath(root, node.id);
    const parent = path.length > 1 ? path[path.length - 2] : null;
    const grandparent = path.length > 2 ? path[path.length - 3] : null;

    const isExponentDenominator = (grandparent && grandparent.type === 'pow' && parent === grandparent.exp);
    const isStandardDenominator = (parent.type === 'div' && node === parent.den && !isExponentDenominator);

    // 1. EXTRACT FROM SOURCE
    if (isExponentDenominator || isStandardDenominator) {
        if (grandparent) {
             if (grandparent.type === 'mult' || grandparent.type === 'add') {
                  const idx = grandparent.children.indexOf(parent);
                  grandparent.children[idx] = parent.num;
             } else if (grandparent.type === 'pow') {
                  grandparent.exp = parent.num;
             }
        } else {
             this.state[sourceSideName] = parent.num;
        }
    } 
    else {
        let remainingSource = null;
        if (parent) {
          if (parent.type === 'add' || parent.type === 'mult') {
            parent.children = parent.children.filter(c => c.id !== node.id);
            remainingSource = parent.children.length === 1 ? parent.children[0] : parent;
          } else if (parent.type === 'div') remainingSource = parent.num;
          else if (parent.type === 'pow') remainingSource = parent.base;
        } else remainingSource = new Atom('1');
        this.state[sourceSideName] = remainingSource;
    }

    // 2. INJECT INTO TARGET
    let targetRoot = this.state[targetSideKey];
    
    // Case: Dragging Negative Sign (-1)
    if (node instanceof Atom && node.val === '-1') {
        // Divide target by -1. 
        // Simplifier will fix 5 / -1 -> -5
        this.state[targetSideKey] = new DivNode(targetRoot, node);
    }
    else if (isExponentDenominator) {
         this.state[targetSideKey] = new PowerNode(targetRoot, node);
    }
    else if (isStandardDenominator) {
         this.state[targetSideKey] = new OpNode('mult', [node, targetRoot]);
    }
    else if (parent && parent.type === 'add') {
        const neg = new OpNode('mult', [new Atom('-1'), node]);
        if (targetRoot.type === 'add') targetRoot.children.push(neg);
        else this.state[targetSideKey] = new OpNode('add', [targetRoot, neg]);
    }
    else if (parent && parent.type === 'mult') {
        this.state[targetSideKey] = new DivNode(targetRoot, node);
    }
    else if (parent && parent.type === 'div') { 
        this.state[targetSideKey] = new OpNode('mult', [node, targetRoot]);
    }
    else if (parent && parent.type === 'pow' && node === parent.exp) {
         if (node instanceof Atom && node.val === '2') {
             const newExp = new DivNode(new Atom('1'), new Atom('2'));
             this.state[targetSideKey] = new PowerNode(targetRoot, newExp);
         } else {
             const newExp = new DivNode(new Atom('1'), node);
             this.state[targetSideKey] = new PowerNode(targetRoot, newExp);
         }
    }
    else if (!parent) {
        const neg = new OpNode('mult', [new Atom('-1'), node]);
        this.state[targetSideKey] = new OpNode('add', [targetRoot, neg]);
        this.state[sourceSideName] = new Atom('0');
    }

    this.simplifyStep();
    this.checkAutoFlip();
    this.render();
  }

  // --- HELPER: AUTO FLIP ---
  checkAutoFlip() {
    const r = this.state.rhs;
    const l = this.state.lhs;
    // If RHS is simple var and LHS is number or expression, flip.
    const isRhsVar = (r instanceof Atom && isNaN(parseFloat(r.val))); 
    const isLhsNotVar = !(l instanceof Atom && isNaN(parseFloat(l.val))); 
    
    if (isRhsVar && isLhsNotVar) {
        this.state.rhs = l;
        this.state.lhs = r;
    }
  }

  // --- SIMPLIFIER ---
  simplifyStep() {
    this.state.lhs = this.simplifyNode(this.state.lhs);
    this.state.rhs = this.simplifyNode(this.state.rhs);
  }

  simplifyNode(node) {
    if (!node) return null;
    if (node.children) node.children = node.children.map(c => this.simplifyNode(c));
    if (node.num) { node.num = this.simplifyNode(node.num); node.den = this.simplifyNode(node.den); }
    if (node.base) { node.base = this.simplifyNode(node.base); node.exp = this.simplifyNode(node.exp); }

    if (node.type === 'add' || node.type === 'mult') {
        let newChildren = [];
        node.children.forEach(c => {
            if (c.type === node.type) newChildren.push(...c.children); else newChildren.push(c);
        });
        node.children = newChildren;
    }

    if (node.type === 'add') {
        let sum = 0; let nonConst = [];
        node.children.forEach(c => {
             if (c instanceof Atom && !isNaN(c.val)) sum += parseFloat(c.val); else nonConst.push(c);
        });
        if (sum !== 0) nonConst.push(new Atom(Number.isInteger(sum) ? sum.toString() : sum.toFixed(2).replace(/\.00$/,'')));
        if (nonConst.length === 0) return new Atom('0');
        if (nonConst.length === 1) return nonConst[0];
        node.children = nonConst;
    }
    
    if (node.type === 'mult') {
        let prod = 1; let nonConst = [];
        node.children.forEach(c => {
             if (c instanceof Atom && !isNaN(c.val)) prod *= parseFloat(c.val); else nonConst.push(c);
        });
        if (prod !== 1) nonConst.unshift(new Atom(Number.isInteger(prod) ? prod.toString() : prod.toFixed(2).replace(/\.00$/,'')));
        if (prod === 0) return new Atom('0');
        if (nonConst.length === 0) return new Atom('1');
        if (nonConst.length === 1) return nonConst[0];
        node.children = nonConst;
    }

    if (node.type === 'div') {
        // FIX: Handle division by -1 (x / -1 -> -1 * x)
        if (node.den instanceof Atom && node.den.val === '-1') {
             return new OpNode('mult', [new Atom('-1'), node.num]);
        }
        if (node.den instanceof Atom && node.den.val === '1') return node.num;
        if (node.num instanceof Atom && !isNaN(node.num.val) && node.den instanceof Atom && !isNaN(node.den.val)) {
            const res = parseFloat(node.num.val) / parseFloat(node.den.val);
            if (Number.isInteger(res)) return new Atom(res.toString());
        }
    }
    if (node.type === 'pow') {
        if (node.exp instanceof Atom && node.exp.val === '1') return node.base;
    }
    return node;
  }

  // --- RENDERER ---
  render() {
    const lC = document.getElementById('LHS'); const rC = document.getElementById('RHS');
    lC.innerHTML = ''; rC.innerHTML = '';
    lC.appendChild(this.createDom(this.state.lhs, 'LHS', this.state.lhs));
    rC.appendChild(this.createDom(this.state.rhs, 'RHS', this.state.rhs));
  }

  createDom(node, sideName, sideRoot, parentType = null) {
    if (!node) return document.createElement('span');
    const path = this.findPath(sideRoot, node.id);
    const movableNode = this.getMovableNode(path, sideRoot);
    const isMovable = !!movableNode;
    
    const el = document.createElement('div');
    el.className = `node ${isMovable ? 'draggable' : 'locked'}`;
    el.id = node.id;
    if (isMovable) el.onmousedown = (e) => { e.stopPropagation(); this.startDrag(e, movableNode, sideName); };
    else el.onmousedown = (e) => { e.stopPropagation(); this.toast("Locked"); };

    let needsParen = false;
    if (node.type === 'add' && (parentType === 'mult' || parentType === 'pow')) needsParen = true;
    if (node.type === 'mult' && parentType === 'pow') needsParen = true;
    if (node.type === 'div' && parentType === 'pow') needsParen = true;

    if (needsParen) { const p = document.createElement('span'); p.className='paren'; p.innerHTML='('; el.appendChild(p); }

    if (node instanceof Atom) el.innerHTML += katex.renderToString(node.val);
    else if (node.type === 'add') {
        node.children.forEach((c, i) => {
            if (i > 0) {
                let isNeg = false;
                if (c.type === 'mult' && c.children[0] instanceof Atom && c.children[0].val === '-1') isNeg = true;
                if (!isNeg) {
                    const op = document.createElement('span'); op.className = 'op'; op.innerHTML = '+'; el.appendChild(op);
                }
            }
            el.appendChild(this.createDom(c, sideName, sideRoot, 'add'));
        });
    }
    else if (node.type === 'mult') {
        node.children.forEach((c, i) => {
            // RENDER DRAGGABLE MINUS
            if (c instanceof Atom && c.val === '-1' && i === 0) {
                const isNegMovable = this.checkMove(c, this.findPath(sideRoot, c.id), sideRoot);
                const sign = document.createElement('div'); 
                sign.className = `negative-sign ${isNegMovable ? 'draggable' : ''}`;
                sign.innerHTML = '−'; 
                if (isNegMovable) {
                    sign.onmousedown = (e) => { e.stopPropagation(); this.startDrag(e, c, sideName); };
                }
                el.appendChild(sign);
            } else el.appendChild(this.createDom(c, sideName, sideRoot, 'mult'));
        });
    }
    else if (node.type === 'div') {
        const frac = document.createElement('div'); frac.className = 'fraction';
        frac.appendChild(this.createDom(node.num, sideName, sideRoot, 'div'));
        const line = document.createElement('div'); line.className = 'frac-line'; frac.appendChild(line);
        frac.appendChild(this.createDom(node.den, sideName, sideRoot, 'div'));
        el.appendChild(frac);
        el.className = 'node'; 
    }
    else if (node.type === 'pow') {
        let isRoot = false;
        if (node.exp.type === 'div' && node.exp.num.val === '1' && node.exp.den.val === '2') {
             isRoot = true;
        }

        if (isRoot) {
            const wrapper = document.createElement('div'); wrapper.className = 'root-wrapper';
            const sym = document.createElement('div');
            sym.className = `root-symbol ${isMovable ? 'draggable' : 'locked'}`;
            sym.innerHTML = `<svg class="root-svg" viewBox="0 0 10 20" preserveAspectRatio="none"><path d="M0,12 L4,18 L10,0" vector-effect="non-scaling-stroke" fill="none" stroke="currentColor" stroke-width="2"/></svg>`;
            
            sym.onmousedown = (e) => { 
                e.stopPropagation(); 
                if (isMovable) {
                    this.startDrag(e, node.exp.den, sideName); 
                } else {
                    this.toast("Isolate Root"); 
                }
            };
            
            const content = document.createElement('div'); content.className = 'root-content';
            content.appendChild(this.createDom(node.base, sideName, sideRoot, 'root'));
            
            wrapper.appendChild(sym);
            wrapper.appendChild(content);
            el.appendChild(wrapper);
            el.className = 'node';
        } else {
            el.appendChild(this.createDom(node.base, sideName, sideRoot, 'pow'));
            const sup = document.createElement('div');
            let isFractionExp = (node.exp.type === 'div');
            sup.className = isFractionExp ? 'fraction-exp' : 'superscript';
            sup.appendChild(this.createDom(node.exp, sideName, sideRoot, 'pow'));
            el.appendChild(sup);
        }
    }

    if (needsParen) { const p = document.createElement('span'); p.className='paren'; p.innerHTML=')'; el.appendChild(p); }
    return el;
  }

  findPath(root, targetId, currentPath = []) {
    if (!root) return null;
    const newPath = [...currentPath, root];
    if (root.id === targetId) return newPath;
    let res = null;
    if (root.children) for (let c of root.children) { res = this.findPath(c, targetId, newPath); if (res) return res; }
    if (root.num) res = this.findPath(root.num, targetId, newPath) || this.findPath(root.den, targetId, newPath);
    if (root.base) res = this.findPath(root.base, targetId, newPath) || this.findPath(root.exp, targetId, newPath);
    return res;
  }

  startDrag(e, node, sideName) {
    const ghost = document.createElement('div');
    ghost.className = 'ghost';
    ghost.innerText = (node instanceof Atom) ? node.val : 'TERM';
    if (node instanceof Atom && node.val === '-1') ghost.innerText = '-';
    document.body.appendChild(ghost);
    const move = (ev) => {
        ghost.style.left = ev.clientX + 'px'; ghost.style.top = ev.clientY + 'px';
        const mid = window.innerWidth / 2;
        const target = ev.clientX < mid ? 'LHS' : 'RHS';
        document.getElementById('LHS').classList.toggle('drag-target', target === 'LHS' && sideName !== 'LHS');
        document.getElementById('RHS').classList.toggle('drag-target', target === 'RHS' && sideName !== 'RHS');
    };
    const drop = (ev) => {
        document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', drop);
        ghost.remove();
        document.querySelectorAll('.side').forEach(s => s.classList.remove('drag-target'));
        const mid = window.innerWidth / 2;
        const targetSide = ev.clientX < mid ? 'LHS' : 'RHS';
        if (targetSide !== sideName) this.move(node, targetSide);
    };
    document.addEventListener('mousemove', move); document.addEventListener('mouseup', drop);
  }

  save() { this.history.push(JSON.stringify(this.state)); }
  flip() { this.save(); [this.state.lhs, this.state.rhs] = [this.state.rhs, this.state.lhs]; this.render(); }
  toast(msg) { const t = document.getElementById('toast'); t.innerText = msg; t.className = 'show'; setTimeout(() => t.className = '', 2500); }
}

const engine = new AlgebraEngine();
engine.load();
</script>
</body>
</html>
