<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Drag Equation Transposer</title>

  <!-- Nerdamer (local) -->
  <script src="./vendor/nerdamer.core.js"></script>
  <script src="./vendor/Algebra.js"></script>
  <script src="./vendor/Solve.js"></script>
  <script src="./vendor/Extra.js"></script>

  <!-- KaTeX (CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --card:rgba(255,255,255,.06);
      --stroke:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.95);
      --muted:rgba(255,255,255,.65);
      --accent:#7c5cff;
      --ok:#34d399;
      --bad:#ff4d6d;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 10% 10%, rgba(124,92,255,.25), transparent 60%),
        radial-gradient(900px 500px at 90% 20%, rgba(45,212,191,.18), transparent 55%),
        radial-gradient(1000px 700px at 50% 120%, rgba(255,77,109,.10), transparent 55%),
        var(--bg);
    }

    .wrap{max-width:1200px;margin:0 auto;padding:20px 16px 26px}
    header{display:flex;gap:12px;flex-wrap:wrap;justify-content:space-between;align-items:flex-end;margin-bottom:12px}
    h1{margin:0;font-size:20px;letter-spacing:.2px}
    .sub{margin:0;color:var(--muted);font-size:13px}

    .topbar{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:12px;
      align-items:start;
      margin-bottom:12px;
    }
    .card{
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, var(--card), rgba(255,255,255,.04));
      border-radius:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.28);
      backdrop-filter: blur(10px);
    }
    .card.pad{padding:12px}
    label{display:block;font-size:12px;color:var(--muted);margin:0 0 6px}
    textarea{
      width:100%;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.20);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      outline:none;
      font-size:14px;
      font-family:var(--mono);
      min-height:70px;
      resize:vertical;
    }
    .actions{display:flex;flex-direction:column;gap:10px}
    .btn{
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.08);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      font-size:13px;
      user-select:none;
      text-align:center;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
    }
    .btn:hover{background:rgba(255,255,255,.12)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{
      border-color: rgba(124,92,255,.5);
      background: linear-gradient(180deg, rgba(124,92,255,.35), rgba(124,92,255,.18));
    }
    .btn.danger{
      border-color: rgba(255,77,109,.5);
      background: linear-gradient(180deg, rgba(255,77,109,.30), rgba(255,77,109,.12));
    }

    .status{
      display:flex;align-items:center;gap:8px;
      margin-top:10px;font-size:12px;color:var(--muted)
    }
    .dot{width:10px;height:10px;border-radius:50%;background:rgba(255,255,255,.35)}
    .dot.ok{background:var(--ok)}
    .dot.bad{background:var(--bad)}

    /* MASSIVE equation box */
    .bigEq{
      height: 70vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      overflow:auto;
    }
    .bigEqInner{
      width:100%;
      display:flex;
      justify-content:center;
      align-items:center;
      padding:24px;
      border-radius:22px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.16);
      min-height: calc(70vh - 36px);
    }

    /* KaTeX sizing + bold white feel */
    .katex{font-size: clamp(34px, 5vw, 72px); font-weight:800;}
    .katex *{font-weight:800;}
    .katex, .katex .mord, .katex .mrel, .katex .mbin, .katex .mop { color: rgba(255,255,255,.98) !important; }

    /* Make equation feel like “ink”, not UI */
    .noSelect, .noSelect *{
      user-select:none !important;
      -webkit-user-select:none !important;
      -ms-user-select:none !important;
    }

    /* Draggable parts INSIDE KaTeX (invisible tiles) */
    .tile{
      cursor:grab;
      border-radius:10px;
      padding:2px 4px;
      margin:0 2px;
      display:inline-block;
      position:relative;
    }
    .tile:hover{
      background: rgba(255,255,255,.06);
      outline: 1px solid rgba(255,255,255,.10);
    }
    .tile:active{cursor:grabbing}

    /* Drop feedback */
    .eqDropL, .eqDropR{ transition: background .12s ease, outline .12s ease; }
    .dropActive{
      background: rgba(124,92,255,.07) !important;
      outline: 2px solid rgba(124,92,255,.45) !important;
    }

    /* Small footer */
    .footer{
      margin-top:12px;
      display:flex;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:12px;
      font-family:var(--mono);
    }

    @media (max-width: 980px){
      .topbar{grid-template-columns:1fr}
      .actions{flex-direction:row;flex-wrap:wrap}
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Drag Equation Transposer</h1>
        <p class="sub">Drag a highlighted top-level <b>term</b> or <b>factor</b> across <span style="font-family:var(--mono)">=</span>. Internal pieces are illegal (snap back).</p>
      </div>
      <div class="sub" style="font-family:var(--mono)">
        View:
        <span id="viewLabel" style="font-weight:800;color:rgba(255,255,255,.9)">Terms</span>
        <span style="opacity:.7">(| press V to toggle)</span>
      </div>
    </header>

    <div class="topbar">
      <div class="card pad">
        <label>Equation (use <span style="font-family:var(--mono)">=</span>; subscripts like <span style="font-family:var(--mono)">v_f</span>, <span style="font-family:var(--mono)">v_i</span>. Use explicit multiplication if needed: <span style="font-family:var(--mono)">f=m*a</span>.)</label>
        <textarea id="eqInput">a=(v_f-v_i)/t</textarea>
        <div class="status">
          <span class="dot" id="statusDot"></span>
          <span id="statusText">Ready.</span>
        </div>
      </div>
      <div class="actions">
        <div class="btn primary" id="loadBtn">Load</div>
        <div class="btn" id="undoBtn">Undo</div>
        <div class="btn danger" id="resetBtn">Reset</div>
      </div>
    </div>

    <div class="card bigEq">
      <div class="bigEqInner noSelect" id="eqBox"></div>
    </div>

    <div class="footer">
      <div>Tips: move whole brackets first to “expose” parts. Example: move <span style="color:#fff">t</span> across gives <span style="color:#fff">a·t = v_f - v_i</span>.</div>
      <div id="stepsText">steps: 0</div>
    </div>
  </div>

<script>
/* -----------------------------
   Core goals:
   - KaTeX renders pretty math
   - We inject \htmlId + \htmlClass around ONLY top-level movable pieces
   - Drag across '=' applies algebraically legal operations using Nerdamer
-------------------------------- */

const $ = (id) => document.getElementById(id);

let state = {
  original: { lhs:"", rhs:"" },
  current:  { lhs:"", rhs:"" },
  view: "terms", // "terms" or "factors"
  history: []
};

function setStatus(ok, msg){
  $("statusDot").className = "dot " + (ok ? "ok" : "bad");
  $("statusText").textContent = msg;
}

function cleanEqString(s){ return s.replace(/\s+/g, " ").trim(); }

function splitEquation(eqStr){
  const s = cleanEqString(eqStr);
  const idx = s.indexOf("=");
  if(idx < 0) throw new Error("Equation must contain '=' (e.g. a=(v_f-v_i)/t).");
  const lhs = s.slice(0, idx).trim();
  const rhs = s.slice(idx+1).trim();
  if(!lhs || !rhs) throw new Error("Both sides must be non-empty.");
  return { lhs, rhs };
}

/* Insert explicit multiplication in common student-style inputs:
   - "ma" -> "m*a" (letters adjacent)
   - "2a" -> "2*a"
   - ")a" -> ")*a"
   - "a(" -> "a*(" (rare but can help)
*/
function insertImplicitMul(s){
  let x = s;

  // between number and letter or "("
  x = x.replace(/(\d)([A-Za-z(])/g, "$1*$2");
  // between letter or ")" and number
  x = x.replace(/([A-Za-z)])(\d)/g, "$1*$2");
  // between letter and letter
  x = x.replace(/([A-Za-z_}])([A-Za-z_])/g, "$1*$2");
  // between ")" and letter or "("
  x = x.replace(/(\))([A-Za-z(])/g, "$1*$2");
  // between letter and "("
  x = x.replace(/([A-Za-z_}])(\()/g, "$1*$2");

  return x;
}

function nerdNormalize(expr){
  // normalize with explicit multiplication inserted
  const safe = insertImplicitMul(expr);
  return nerdamer(safe).expand().toString();
}

/* --- view decomposition --- */

/* TERMS:
   We split top-level additions/subtractions.
   We store payload as a SIGNED expression chunk, e.g.
   + (v_f/t)
   - (v_i/t)
*/
function splitTopLevelAdd(expr){
  const s = nerdNormalize(expr);
  const out = [];
  let depth = 0;
  let buf = "";
  let sign = +1;

  function flush(){
    const t = buf.trim();
    if(t) out.push({ sign, text: t });
    buf = "";
  }

  for(let i=0;i<s.length;i++){
    const ch = s[i];
    if(ch === "(") depth++;
    if(ch === ")") depth--;
    if(depth === 0 && (ch === "+" || ch === "-")){
      flush();
      sign = (ch === "+") ? +1 : -1;
    } else {
      buf += ch;
    }
  }
  flush();
  return out.length ? out : [{ sign:+1, text:s.trim() }];
}

/* FACTORS:
   We want REAL numerator/denominator factors (not t^(-1)).
   So we:
   - split top-level by * and /
   - AND also pull out powers with exponent -1 into denominator when possible.
*/
function splitTopLevelMulFrac(expr){
  const s = nerdNormalize(expr);

  let depth = 0;
  let buf = "";
  let mode = "num";
  const num = [];
  const den = [];

  function flush(){
    const t = buf.trim();
    if(!t) { buf=""; return; }

    // convert something like (t)^(-1) or t^(-1) into denominator factor t
    const m = t.match(/^(.+)\^\(-1\)$/);
    if(m){
      const base = m[1].trim();
      den.push(base);
    } else {
      (mode === "num" ? num : den).push(t);
    }
    buf = "";
  }

  for(let i=0;i<s.length;i++){
    const ch = s[i];
    if(ch === "(") depth++;
    if(ch === ")") depth--;
    if(depth === 0 && (ch === "*" || ch === "/")){
      flush();
      mode = (ch === "/") ? "den" : "num";
    } else {
      buf += ch;
    }
  }
  flush();

  if(num.length === 0 && den.length === 0) return { num:[s.trim()], den:[] };
  if(num.length === 0) num.push("1");
  return { num, den };
}

/* --- TeX building (KaTeX + draggable IDs) --- */

const payloadById = new Map();

function escTex(s){
  // Nerdamer produces TeX-friendly-ish strings via toTeX; we avoid manual escaping here.
  return s;
}

function nerdToTeX(expr){
  const n = nerdamer(insertImplicitMul(expr));
  if(typeof n.toTeX === "function") return n.toTeX();
  if(typeof n.text === "function") return n.text("latex");
  // fallback plain
  return "\\text{" + String(n.toString()).replace(/\\/g,"\\\\").replace(/}/g,"\\}") + "}";
}

function tile(texInside, id){
  // Requires trust:true in katex.render
  return `\\htmlClass{tile}{\\htmlId{${id}}{${texInside}}}`;
}

function buildSideTeX(sideName, expr){
  if(state.view === "terms"){
    const terms = splitTopLevelAdd(expr);
    const chunks = terms.map((t, i) => {
      const id = `${sideName}_term_${i}`;
      const signedExpr = (t.sign === 1) ? `(${t.text})` : `-(${t.text})`;
      payloadById.set(id, { kind:"term", side:sideName, signedExpr });

      const inner = nerdToTeX(t.text);
      const withSign = (t.sign === 1)
        ? (i===0 ? `${tile(inner, id)}` : `+${tile(inner, id)}`)
        : (i===0 ? `-${tile(inner, id)}` : `-${tile(inner, id)}`);

      return withSign;
    });

    return chunks.join("");
  }

  // factors view
  const f = splitTopLevelMulFrac(expr);

  function joinFactors(arr, where){
    if(arr.length === 0) return "1";
    return arr.map((x, i) => {
      const id = `${sideName}_fac_${where}_${i}`;
      payloadById.set(id, { kind:"factor", side:sideName, where, factorExpr:`(${x})` });
      const inner = nerdToTeX(x);
      return tile(inner, id);
    }).join("\\cdot ");
  }

  const numTex = joinFactors(f.num, "num");
  const denTex = joinFactors(f.den, "den");

  if(f.den.length === 0){
    return numTex;
  }
  return `\\frac{${numTex}}{${denTex}}`;
}

function buildEquationTeX(lhsExpr, rhsExpr){
  payloadById.clear();

  const lhs = buildSideTeX("lhs", lhsExpr);
  const rhs = buildSideTeX("rhs", rhsExpr);

  // Make the two sides droppable areas too
  // (so you can drop onto either side; we use wrapping ids)
  const lhsWrap = `\\htmlClass{eqDropL}{\\htmlId{eqDropL}{${lhs}}}`;
  const rhsWrap = `\\htmlClass{eqDropR}{\\htmlId{eqDropR}{${rhs}}}`;

  return `${lhsWrap}= ${rhsWrap}`;
}

/* --- algebra moves --- */

/* Term move:
   If user drags a signed term chunk across '=', legal action is:
   subtract that signed term from BOTH sides.
*/
function moveTermAcross(payload, toSide){
  const from = payload.side;
  if(from === toSide){
    setStatus(false, "Drop on the other side of '=' to transpose.");
    return;
  }
  const T = payload.signedExpr; // already includes sign

  const lhs = nerdNormalize(`(${state.current.lhs}) - (${T})`);
  const rhs = nerdNormalize(`(${state.current.rhs}) - (${T})`);

  state.current = { lhs, rhs };
  pushHistory(`Moved term across '=' (subtracted ${T} from both sides)`);
  render();
  setStatus(true, "Moved term.");
}

/* Factor move:
   If factor is in numerator on dragged side:
     divide BOTH sides by factor
   If factor is in denominator on dragged side:
     multiply BOTH sides by factor
*/
function moveFactorAcross(payload, toSide){
  const from = payload.side;
  if(from === toSide){
    setStatus(false, "Drop on the other side of '=' to transpose.");
    return;
  }
  const F = payload.factorExpr;

  let lhs = state.current.lhs;
  let rhs = state.current.rhs;

  if(payload.where === "num"){
    lhs = nerdNormalize(`(${lhs}) / (${F})`);
    rhs = nerdNormalize(`(${rhs}) / (${F})`);
  } else {
    lhs = nerdNormalize(`(${lhs}) * (${F})`);
    rhs = nerdNormalize(`(${rhs}) * (${F})`);
  }

  state.current = { lhs, rhs };
  pushHistory(`Moved factor across '=' (${payload.where==="num"?"÷":"×"} ${F} on both sides)`);
  render();
  setStatus(true, "Moved factor.");
}

/* --- history --- */
function pushHistory(desc){
  state.history.push({ lhs: state.current.lhs, rhs: state.current.rhs, desc });
  $("stepsText").textContent = `steps: ${state.history.length}`;
}
function undo(){
  if(state.history.length <= 1){
    setStatus(false, "Nothing to undo.");
    return;
  }
  state.history.pop();
  const prev = state.history[state.history.length-1];
  state.current = { lhs: prev.lhs, rhs: prev.rhs };
  $("stepsText").textContent = `steps: ${state.history.length}`;
  render();
  setStatus(true, "Undone.");
}
function reset(){
  if(!state.original.lhs){
    setStatus(false, "Load an equation first.");
    return;
  }
  state.current = { ...state.original };
  state.history = [{ lhs: state.current.lhs, rhs: state.current.rhs, desc:"Loaded equation" }];
  $("stepsText").textContent = `steps: 1`;
  render();
  setStatus(true, "Reset.");
}

/* --- render + wiring drag/drop on KaTeX DOM --- */

let dragPayload = null;

function attachTileHandlers(){
  // Each tile gets pointer-based drag (more reliable than HTML5 drag on KaTeX spans)
  const tiles = $("eqBox").querySelectorAll(".tile");
  tiles.forEach(t => {
    const id = t.id;
    const payload = payloadById.get(id);
    if(!payload) return;

    // Center-ish hover target: use padding + border-radius already
    // Force no text selection while dragging
    t.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      dragPayload = payload;
      t.setPointerCapture(e.pointerId);
      t.style.background = "rgba(255,255,255,.08)";
      t.style.outline = "1px solid rgba(255,255,255,.16)";
    });

    t.addEventListener("pointerup", (e) => {
      if(!dragPayload) return;
      // drop side detection by x position relative to "=" in the rendered equation box
      const box = $("eqBox").getBoundingClientRect();
      const mid = box.left + box.width/2;
      const toSide = (e.clientX < mid) ? "lhs" : "rhs";

      // Only allow across-equals moves
      if(dragPayload.kind === "term") moveTermAcross(dragPayload, toSide);
      if(dragPayload.kind === "factor") moveFactorAcross(dragPayload, toSide);

      dragPayload = null;
      t.style.background = "transparent";
      t.style.outline = "none";
    });

    t.addEventListener("pointercancel", () => { dragPayload = null; });
  });
}

function render(){
  if(!window.katex) throw new Error("KaTeX not loaded.");
  if(typeof window.nerdamer !== "function") throw new Error("Nerdamer not loaded.");

  const tex = buildEquationTeX(state.current.lhs, state.current.rhs);

  $("eqBox").innerHTML = "";
  katex.render(tex, $("eqBox"), {
    displayMode: true,
    throwOnError: false,
    strict: "ignore",
    trust: true   // REQUIRED for \htmlId / \htmlClass
  });

  attachTileHandlers();
}

function loadEquation(){
  const raw = $("eqInput").value.trim();
  const { lhs, rhs } = splitEquation(raw);

  // validate parse
  nerdamer(insertImplicitMul(lhs));
  nerdamer(insertImplicitMul(rhs));

  state.original = { lhs: nerdNormalize(lhs), rhs: nerdNormalize(rhs) };
  state.current  = { ...state.original };
  state.history  = [{ lhs: state.current.lhs, rhs: state.current.rhs, desc:"Loaded equation" }];

  $("stepsText").textContent = `steps: 1`;
  render();
  setStatus(true, "Loaded. Drag any highlighted top-level part across '='.");
}

/* --- UI --- */
function setView(v){
  state.view = v;
  $("viewLabel").textContent = (v==="terms" ? "Terms" : "Factors");
  render();
  setStatus(true, `View: ${v}.`);
}

$("loadBtn").addEventListener("click", () => {
  try{ loadEquation(); } catch(e){ setStatus(false, e.message || String(e)); }
});
$("undoBtn").addEventListener("click", () => {
  try{ undo(); } catch(e){ setStatus(false, e.message || String(e)); }
});
$("resetBtn").addEventListener("click", () => {
  try{ reset(); } catch(e){ setStatus(false, e.message || String(e)); }
});

// V toggles view
window.addEventListener("keydown", (e) => {
  if(e.key.toLowerCase() === "v"){
    setView(state.view === "terms" ? "factors" : "terms");
  }
});

// Boot
(function boot(){
  try{
    setStatus(true, "Ready. Hit Load.");
    loadEquation();
  }catch(e){
    setStatus(false, e.message || String(e));
  }
})();
</script>
</body>
</html>
